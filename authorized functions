----- structs -----

struct addrinfo {
	int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
	int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
	int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
	int              ai_protocol;  // use 0 for "any"
	size_t           ai_addrlen;   // size of ai_addr in bytes
	struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
	char            *ai_canonname; // full canonical hostname

	struct addrinfo *ai_next;      // linked list, next node
};

struct sockaddr {
	unsigned short    sa_family;    // address family, AF_xxx
	char              sa_data[14];  // 14 bytes of protocol address
};

struct sockaddr_in {
	short int          sin_family;  // Address family, AF_INET
	unsigned short int sin_port;    // Port number
	struct in_addr     sin_addr;    // Internet address
	unsigned char      sin_zero[8]; // Same size as struct sockaddr
};

struct in_addr {
	uint32_t s_addr; // that's a 32-bit int (4 bytes)
};

----- get info functions -----

network or host conversion for ip or port
htons (host to network short)
htonl (host to network long)
ntohs (network to host short)
ntohl (network to host long)

inet_addr() // Does work only with IPv4 and doesn't with 255.255.255.255

! Recode getaddrinfo to simplify comprehension ?

----- Setup socket functions -----

socket(domain, type, protocol) PF_INET for IPv4, SOCK_STREAM for TCP, 0 / return sockfd
setsockopt() can be usefull to reuse a port that was previously already used if relauch
fcntl(sockfd, cmd, arg) to set the socket to be non-blocking or async
bind(sockfd, addr, len) bind to a port
+ example :
+	int sockfd;
+	struct sockaddr_in my_addr;
+
+	sockfd = socket(PF_INET, SOCK_STREAM, 0);
+
+	my_addr.sin_family = AF_INET;
+	my_addr.sin_port = htons(MYPORT);     // short, network byte order
+	my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
+	memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);
+
+	bind(sockfd, (struct sockaddr *)&my_addr, sizeof my_addr);

----- Connect / Listen socket functions -----

connect(sockfd, sockaddr, len) to connect to a remote host
 OR
listen(sockfd, backlog (nb of connections max)) to wait for incoming connections
accept(sockfd, sockaddr, socklen) accept and fill the client infos

----- Multiplexing fds -----

poll
select

epoll
epoll_create
epoll_ctl
epoll_wait

kqueue
kevent

----- Use socket functions -----

send(sockfd, msg, len, flags) returns nb of bytes sent / need to send in many packages of 1K for example
recv(sockfd, buf, len, flags) returns nb of bytes red, if 0 = closed connection
close(sockfd) stop sending and receiving datas and free fd
fork()
getsockname(sockfd, sockaddr, namelen) to know the name of the socket ? For what ??


https://beej.us/guide/bgnet/html/index-wide.html#poll

https://www.geeksforgeeks.org/socket-programming-cc/

https://www.postman.com/
To send requests to the server easily