----- structs -----

struct addrinfo {
	int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
	int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
	int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
	int              ai_protocol;  // use 0 for "any"
	size_t           ai_addrlen;   // size of ai_addr in bytes
	struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
	char            *ai_canonname; // full canonical hostname

	struct addrinfo *ai_next;      // linked list, next node
};

struct sockaddr {
	unsigned short    sa_family;    // address family, AF_xxx
	char              sa_data[14];  // 14 bytes of protocol address
};

struct sockaddr_in {
	short int          sin_family;  // Address family, AF_INET
	unsigned short int sin_port;    // Port number
	struct in_addr     sin_addr;    // Internet address
	unsigned char      sin_zero[8]; // Same size as struct sockaddr
};

struct in_addr {
	uint32_t s_addr; // that's a 32-bit int (4 bytes)
};

struct pollfd {
	int fd;         // the socket descriptor
	short events;   // bitmap of events we're interested in
	short revents;  // when poll() returns, bitmap of events that occurred
};


----- get info functions -----

network or host conversion for ip or port - https://beej.us/guide/bgnet/html/index-wide.html#byte-order
htons (host to network short)
htonl (host to network long)
ntohs (network to host short)
ntohl (network to host long)

inet_addr() // Does work only with IPv4 and doesn't with 255.255.255.255

Use getaddrinfo instead - https://beej.us/guide/bgnet/html/index-wide.html#getaddrinfoprepare-to-launch


----- Setup socket functions ----- https://beej.us/guide/bgnet/html/index-wide.html#system-calls-or-bust

socket(domain, type, protocol) PF_INET for IPv4, SOCK_STREAM for TCP, 0 / return sockfd
setsockopt() can be usefull to reuse a port that was previously already used if relauch
fcntl(sockfd, cmd, arg) to set the socket to be non-blocking or async
bind(sockfd, addr, len) bind to a port
+ example :
+	int sockfd;
+	struct sockaddr_in my_addr;
+
+	sockfd = socket(PF_INET, SOCK_STREAM, 0);
+
+	my_addr.sin_family = AF_INET;
+	my_addr.sin_port = htons(MYPORT);     // short, network byte order
+	my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
+	memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);
+
+	bind(sockfd, (struct sockaddr *)&my_addr, sizeof my_addr);


----- Connect / Listen socket functions -----

to connect to a server - https://beej.us/guide/bgnet/html/index-wide.html#connect
connect(sockfd, sockaddr, len) to connect to a remote host
 OR
to accept clients - https://beej.us/guide/bgnet/html/index-wide.html#listen
listen(sockfd, backlog (nb of connections max)) to wait for incoming connections
accept(sockfd, sockaddr, socklen) accept and fill the client infos


----- Multiplexing fds -----

poll - https://beej.us/guide/bgnet/html/index-wide.html#poll
poll(struct fds, nb of fds, timeout) POLLIN and POLLOUT to specify event to lookout / returns the nb of events happened
select - https://beej.us/guide/bgnet/html/index-wide.html#select
select(nbfds, *read, *write, *except, timeout) send set of fd and return them with bitwise activated if event occured
+ FD_SET(int fd, fd_set *set);		Add fd to the set.
+ FD_CLR(int fd, fd_set *set);		Remove fd from the set.
+ FD_ISSET(int fd, fd_set *set);	Return true if fd is in the set.
+ FD_ZERO(fd_set *set);				Clear all entries from the set.

epoll - https://granulate.io/using-epoll-might-wanna-think-about-batching-epoll_ctl/
epoll_create(size) to create a new poll / returns an int epfd
epoll_create1(flags)
epoll_ctl(epfd, operation(ADD, DEL, MOD), fd, event(wanted event)) update the event associated with the fd/server/client
epoll_wait(epfd, *epoll_event, maxevents, timeout)

WTF IS THIS ?
kqueue
kevent


----- Use socket functions -----

send(sockfd, msg, len, flags) returns nb of bytes sent / need to send in many packages of 1K for example
recv(sockfd, buf, len, flags) returns nb of bytes red, if 0 = closed connection
close(sockfd) stop sending and receiving datas and free fd
fork()
getsockname(sockfd, sockaddr, namelen) to know the name of the socket ? For what ??


----- See packages encapsulations... -----

https://beej.us/guide/bgnet/html/index-wide.html#sendall

https://www.geeksforgeeks.org/socket-programming-cc/

https://www.postman.com/
To send requests to the server easily